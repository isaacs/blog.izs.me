---
layout: layouts/post.njk
date: 2007-07-16T17:34:31.000Z
redirect_from:
  - /post/146671584/theres-no-room-for-ego-or-zealotry-in-software/
  - /post/146671584/
  - /post/146671584/theres-no-room-for-ego-or-zealotry-in-software
  - /post/146671584
slug: theres-no-room-for-ego-or-zealotry-in-software
tags:
  - code ecosystems
  - sustainability
title: There's no room for Ego or Zealotry in Software (especially on the web)
tumblrid: 146671584
type: text
---
<p>For the last several years, there&rsquo;s been a lot of talk about why web standards are generally a good thing.  And I agree with the vast majority of it.  Writing clean code that sticks to a widely accepted standard is a very good way to help the future programmers who will invariably be touching your stuff once you&rsquo;re gone (or yourself fixing a bug next month or year later.)  In this sense, web standards are a sort of &ldquo;kindness in coding.&rdquo;</p>

<p>However, as with the <abbr title="object oriented programming">OOP</abbr> zealotry that started 20 years ago and is still going strong today, this set of very useful guidelines has turned into a movement.  It has gained enough followers and momentum, and in many cases, seems to have become and End In Itself.</p>

<p>Movements are like organisms.  They survive because the cells that make them up all continually and unthinkingly chant the mantras and make the arguments.  Ideas can be good.  Critically examining them is good.  Being passionate about a good idea is good.  But movements, more often than not, become problematic.</p>

<p>Software is the most complicated thing that humans build, and we haven&rsquo;t really figured it out.  You could even make the argument that we probably never will fully figure out how to create software in a way that doesn&rsquo;t suck to some degree.  That&rsquo;s not to say we don&rsquo;t create some great software, great websites, great programs, etc.  But there are <em>always</em> bugs, and delays, and general chaos along the way, and I believe that there always will be.  The process involves an unknown number of unknowns.  Software is more complicated than the human brain can handle, and that&rsquo;s the only kind of brain that we have.</p>

<p>So, how do you solve a problem when you don&rsquo;t know all the factors, and only have a vague idea of what success looks like?  It&rsquo;s like climbing a mountain when you can&rsquo;t see the top.  You can still see the slope, and can occasionally get glimpses of where you&rsquo;re going, or at least, you know that it&rsquo;s higher up.  If we are to approach quality software, then we must treat this exceedingly complicated problem in a manner that at least <em>approaches</em> quality heuristically, perhaps organically.</p>

<p>Software is a process of making decisions, and then codifying and saving those decisions.  Bad decisions must be pruned ruthlessly, and good ones must be recognized and reused.  In a general sense, this is the heuristic that leads to quality software (or quality <em>anything</em> for that matter.)  The question of what makes a decision &ldquo;good&rdquo; or &ldquo;bad&rdquo; is itself a decision that needs continual evaluation.  And <em>that&rsquo;s</em> where movements get into trouble.</p>

<p>It&rsquo;s easy to say, <q>If it conforms with the w3c&rsquo;s (or Microsoft&rsquo;s or whoever&rsquo;s) standards, then it&rsquo;s good.</q>  I think that this might be a good start, but it&rsquo;s basically an <a href="http://en.wikipedia.org/wiki/Appeal_to_authority">argument from authority</a>.  The w3c is a group of humans.  So is Microsoft.  Humans make mistakes, and have plenty of limitations; that&rsquo;s why we need a heuristic in the first place.</p>

<p>It&rsquo;s also easy to say, <q>If it loads fast and looks right, then it&rsquo;s good.</q>  Sure, but how easy is it to debug it when it doesn&rsquo;t work as expected?  Can new developers add to it easily?  Is it expensive to maintain or re-purpose?</p>

<p>Or, even worse, <q>This was written in (Rails, VB, Django, PHP, C#, valid CSS) so it&rsquo;s good.</q>  I think that a lot of the worst examples of Microsoft horrors were the result of a fanatical attachment to Visual Basic.  I&rsquo;ve seen (ok, &ldquo;written&rdquo;) some terrible CSS that was, nonetheless, technically &ldquo;valid&rdquo; according to the W3C&rsquo;s validator.</p>

<p>Sadly, most developers judge decisions based on their feelings rather than any kind of objective analysis.  <q>I wrote this, and it&rsquo;s clever, and it makes me happy, so it&rsquo;s good.</q>  There is no surer way to end up with a pile of garbage than this approach.  It&rsquo;s hard to let go of something that you worked on, and coders are certainly not the only culprits.  I&rsquo;ve seen execs spend countless hours on a deal that never yielded any value for the company, and designers fight tooth and nail for a visual approach that just didn&rsquo;t work.  Hell, we all have a relative or two with a recipe for something that they love, but which everyone knows is terribly bland.</p>

<p>It&rsquo;s really <em>really</em> hard to let go of this emotional attachment to work.  The reason we feel good when we succeed is that our emotions are attached to our work.  It&rsquo;s why I get up in the morning.  But it&rsquo;s better to attach your feelings to how harsh you are on your code.  Understand that we all write terrible code, but that the difference between bad and good is that good coders recognize this fact and deal with it.</p>

<p>Because of the incredible complexity in software development of any kind, there simply is no room for mindless zealotry or attachment to a movement.  Every project, every site, every module is a little different, and has a slightly different standard of quality.  (Even the rule &ldquo;always head upwards&rdquo; doesn&rsquo;t work for climbing all kinds of mountains.)  Keep the goal in mind, and think about the best way to get there.  Sometimes it&rsquo;ll be the accepted standards, hell most of the time it probably will be, but sometimes it might not.  It&rsquo;s our job to know the difference.</p>

<p>Every once in a while, take a moment to re-evaluate your methods for evaluating the quality of your code.  You may have to let go of something comfortable, and it may sting, but in the end, you&rsquo;ll be better at what you do.</p>
